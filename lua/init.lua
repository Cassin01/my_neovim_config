require("key_register")

-- -- ref: http://invalid-log.blogspot.com/2015/05/lua.html
-- local function instance(class, super, ...)
--    local self = (super and super.new(...) or {})
--    -- __index is the alternative index that is used when the key is not find at self.
--    setmetatable(self, {__index = class})
--    setmetatable(class, {__index = super})
--    return self
-- end
-- 
-- local function table_cunter(table)
--    local lengthNum = 0
--    for k, v in pairs(table) do
--       lengthNum = lengthNum + 1
--    end
--    return lengthNum
-- end
-- 
-- HyperWitch = {
--    new = function(name)
--       local self = instance(HyperWitch)
--       self.name = name
--       return self
--    end;
-- 
--    hyper_witch_syntax = function()
--       vim.cmd([[
-- " https://github.com/liuchengxu/vim-which-key/tree/master/syntax
-- if exists('b:current_syntax')
--   finish
-- endif
-- let b:current_syntax = 'evil_witch'
-- let s:sep = '→'
-- execute 'syntax match WitchKeySeperator' '/'.s:sep.'/' 'contained'
-- execute 'syntax match WitchKey' '/\(^\s*\|\s\{2,}\)\S.\{-}'.s:sep.'/' 'contains=WitchKeySeperator'
-- syntax match WhichKeyGroup / +[0-9A-Za-z_/-]*/
-- syntax region WhichKeyDesc start="^" end="$" contains=WitchKey, WitchKeyGroup, WitchKeySeperator
-- 
-- highlight default link WitchKey          Function
-- highlight default link WitchKeySeperator DiffAdded
-- highlight default link WitchKeyGroup     Keyword
-- highlight default link WitchKeyDesc      Identifier
--          ]])
--    end;
-- 
--    listen_command = function(self)
--       vim.cmd('source ~/.config/nvim/lua/key_register.vim')
--       -- TODO: 全部luaで書く
--    end;
-- 
--    key_selecter = function(self)
--       local matched = self:listen_command()
--       if table_cunter(matched) == 1 then
--          vim.cmd('quit')
--          self.on_matched()
--          self.after_quit()
--       else
--          vim.cmd('quit')
--          self.after_quit()
--       end
--    end;
-- 
-- 
--    load_index = function(self)
--       -- do nothing
--       return {'hoge', 'huga'}
--    end;
-- 
--    on_matched = function(key)
--       -- do nothing
--    end;
-- 
--    after_quit = function()
--       -- do nothing
--    end;
-- 
--    witch = function(self)
--       local buf = vim.api.nvim_create_buf(false, true)
--       local keys_index = self:load_index()
-- 
--       -- vim.api.nvim_buf_set_lines(buf, 0, 0, true, vim.cmd('s:formatter(l:keys_dict, 0)'))
--       local row_offset = vim.go.cmdheight + vim.go.laststatus > 0 and 1 or 0
--       local win_opts = {}
--       win_opts.relative = 'win'
--       win_opts.height = vim.api.nvim_buf_line_count(buf)
--       win_opts.col = 0
--       win_opts.row = vim.go.lines-vim.api.nvim_buf_line_count(buf)-row_offset
--       win_opts.anchor = 'NW'
--       win_opts.style = 'minimal'
--       win_opts.width = vim.go.columns - win_opts.col
--       local win = vim.api.nvim_open_win(buf, true, win_opts)
-- 
--       -- optional: change highlight, otherwise Pmenu is used
--       vim.api.nvim_win_set_option(win, 'winhl', 'Normal:Pmenu')
-- 
--       self.hyper_witch_syntax()
-- 
--       -- 疑似的に半透明にする
--       vim.api.nvim_win_set_option(win, 'winblend', 10)
-- 
--       vim.cmd([[
--       command! WichESC call s:escape()
--       nnoremap <buffer> <silent> <esc> :WichESC<CR>
--          ]])
--       self:key_selecter()
--    end;
-- }
-- 
-- EvilWitch = {
--    new = function(name)
--       local self = instance(EvilWitch, HyperWitch, name)
-- 
--       self.keys_ = Keys:new()
-- 
--       return self
--    end;
-- 
--    load_index = function(self)
--       local index =  self.keys_:get_i()
--       return index
--    end;
-- 
--    on_matched = function(key)
--       local command = 'normal a'..key
--       vim.cmd(command)
--    end;
-- 
--    after_quit = function()
--       vim.cmd('startinsert')
--    end;
-- }
-- 
-- --[[ TEST
-- local evil = EvilWitch.new('evilwitch')
-- evil:witch()
-- ]]
